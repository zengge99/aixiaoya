name: 导出ONNX并跨架构打包（推送到仓库）
on:
  workflow_dispatch:

jobs:
  # ========== 第一阶段：并行构建各架构产物（保留并发） ==========
  build-cross-arch:
    name: 构建 ${{ matrix.arch }} 架构
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: amd64
            platform: linux/amd64
            need_export_onnx: "true"  # 仅amd64需要导出ONNX
          - arch: arm64
            platform: linux/arm64
            need_export_onnx: "false" # arm64跳过导出，复用amd64的ONNX

    steps:
      - name: 拉取仓库代码（含完整历史）
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: 设置Docker Buildx（核心跨架构支持）
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker-container
          use: true

      - name: 安装QEMU跨架构支持
        uses: docker/setup-qemu-action@v3

      # ========== 关键优化：前置导出ONNX（仅amd64执行，原生环境最快） ==========
      - name: 原生导出ONNX（仅amd64执行）
        if: matrix.need_export_onnx == 'true'
        run: |
          # 在GitHub Actions原生amd64环境导出ONNX（比容器内快，且只执行一次）
          sudo apt-get update && sudo apt-get install -y --no-install-recommends python3-pip
          pip install --upgrade pip setuptools wheel
          pip install --no-cache-dir --only-binary=all torch tqdm numpy onnxscript onnxruntime
          python export_onnx.py
          # 保存ONNX文件到固定目录，供后续构建复用
          mkdir -p ./common_files
          cp ./movie_extractor.onnx* ./common_files/ 2>/dev/null || true
          cp ./vocab.pkl ./common_files/ 2>/dev/null || true
          rm -rf ./release || true
          ls -l ./common_files/

      - name: 原生导出ONNX（仅arm64执行）
        if: matrix.need_export_onnx == 'false'
        run: |
          mkdir -p ./common_files
          cp ./vocab.pkl ./common_files/ 2>/dev/null || true
          rm -rf ./release || true
          ls -l ./common_files/

      # ========== 核心：并行构建，arm64跳过ONNX导出 ==========
      - name: 跨架构打包（复用ONNX）
        run: |
          # 根据架构决定是否跳过ONNX导出
          if [ "${{ matrix.need_export_onnx }}" = "true" ]; then
            EXPORT_ONNX_CMD="pip install --no-cache-dir --only-binary=all torch tqdm numpy onnxscript && python export_onnx.py"
          else
            EXPORT_ONNX_CMD="echo '✅ arm64复用预生成的ONNX，跳过导出步骤'"
          fi

          # 创建多阶段Dockerfile（核心修复：去掉scratch的RUN命令）
          cat > Dockerfile.${{ matrix.arch }} << EOF
          # 第一阶段：构建阶段（所有逻辑都在这里完成）
          FROM python:3.12-slim AS builder
          WORKDIR /app
          ARG ARCH
          # 安装基础依赖
          RUN apt-get update && apt-get install -y --no-install-recommends \
              gcc \
              g++ \
              && rm -rf /var/lib/apt/lists/*
          # 升级pip
          RUN pip install --upgrade pip setuptools wheel
          # 复制代码+预生成的ONNX文件（核心：复用）
          COPY . .
          COPY ./common_files/ /app/

          # 第一步：打包可执行文件（所有架构都执行）
          RUN pip uninstall -y torch || true \
              && pip install --no-cache-dir --only-binary=all onnxruntime pyinstaller \
              && pyinstaller --onefile --name movie_extractor --clean infer_onnx.py

          # 第二步：ONNX导出（仅amd64执行，arm64跳过）
          RUN \${EXPORT_ONNX_CMD}

          # 整理产物（提前创建好目录，避免导出阶段需要mkdir）
          RUN mkdir -p /app/release/\${ARCH} \
              && cp /app/dist/movie_extractor /app/release/\${ARCH}/ || true \
              && cp /app/movie_extractor.onnx* /app/release/\${ARCH}/ 2>/dev/null || true \
              && cp /app/vocab.pkl /app/release/\${ARCH}/ 2>/dev/null || true

          # 第二阶段：导出阶段（scratch镜像，仅COPY文件，无RUN）
          FROM scratch AS export-stage
          ARG ARCH
          # 直接COPY文件，依赖builder阶段已创建好的目录，无需在scratch中mkdir
          COPY --from=builder /app/release/\${ARCH}/ /\${ARCH}/
          EOF

          # 并行构建（保留--load，解决驱动提示）
          docker buildx build \
            --platform ${{ matrix.platform }} \
            --build-arg ARCH=${{ matrix.arch }} \
            -f Dockerfile.${{ matrix.arch }} \
            --target export-stage \
            --output type=local,dest=./release \
            --load \
            --cache-from=type=local,src=./buildx-cache \
            --cache-to=type=local,dest=./buildx-cache,mode=max \
            .

          # 验证产物
          mkdir -p release/${{ matrix.arch }}
          if ls release/${{ matrix.arch }}/* 1> /dev/null 2>&1; then
            echo "✅ ${{ matrix.arch }} 架构产物存在："
            ls -l release/${{ matrix.arch }}/
            if [ -f "release/${{ matrix.arch }}/movie_extractor" ]; then
              file release/${{ matrix.arch }}/movie_extractor
            fi
          else
            echo "❌ ${{ matrix.arch }} 架构产物不存在"
            exit 1
          fi
        shell: bash

      # ========== 上传产物 ==========
      - name: 上传${{ matrix.arch }}架构产物
        uses: actions/upload-artifact@v4
        with:
          name: movie_extractor_${{ matrix.arch }}_raw
          path: release/${{ matrix.arch }}/
          if-no-files-found: error

  # ========== 第二阶段：合并产物并提交 ==========
  deploy:
    name: 合并产物并推送到仓库
    runs-on: ubuntu-latest
    needs: build-cross-arch
    steps:
      - name: 拉取仓库代码
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: 创建最终release目录
        run: |
          mkdir -p release
          echo "原始目录内容："
          ls -l release
        shell: bash

      - name: 下载amd64架构产物
        uses: actions/download-artifact@v4
        with:
          name: movie_extractor_amd64_raw
          path: release/amd64

      - name: 下载arm64架构产物
        uses: actions/download-artifact@v4
        with:
          name: movie_extractor_arm64_raw
          path: release/arm64

      - name: 打包ZIP文件
        run: |
          mkdir -p release
          echo "新目录内容："
          ls -l release
          cd release
          zip -r movie_extractor_amd64.zip amd64/
          cp amd64/movie_extractor.onnx* arm64/
          cp amd64/vocab.pkl arm64/
          zip -r movie_extractor_arm64.zip arm64/
          cd ..
          ls -l release/
        shell: bash

      - name: 推送产物到仓库
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          git add release/
          git status
          
          if git diff --cached --quiet; then
            echo "⚠️  无新产物需要提交"
          else
            git commit -m "chore: 新增amd64/arm64架构打包产物（含ZIP包） $(date +%Y%m%d_%H%M%S)"
            git push origin main
            echo "✅ 产物已推送到仓库release目录"
          fi

        shell: bash
