name: 导出ONNX并跨架构打包（推送到仓库）
on:
  workflow_dispatch:

jobs:
  # ========== 第一阶段：并行构建各架构产物 ==========
  build-cross-arch:
    name: 构建 ${{ matrix.arch }} 架构
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          # amd64: 使用官方 ubuntu 镜像，无需 QEMU 模拟
          - arch: amd64
            qemu_arch: x86_64
            docker_image: ubuntu:22.04
            
          # arm64: 使用 arm64v8 专用镜像，开启 aarch64 模拟
          - arch: arm64
            qemu_arch: aarch64
            docker_image: arm64v8/ubuntu:22.04

    steps:
      - name: 拉取仓库代码
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 配置 QEMU (支持跨架构)
        uses: docker/setup-qemu-action@v3

      # 核心修改：使用 base_image 绕过内置 Dockerfile 检查
      - name: 在 ${{ matrix.arch }} 环境中构建
        uses: uraimo/run-on-arch-action@v2
        id: build
        with:
          # 指定架构（arm64需要aarch64，amd64则是x86_64）
          arch: ${{ matrix.qemu_arch }}
          # 必须设置为 none，否则会去查找不存在的 Dockerfile
          distro: none
          # 指定 Docker 镜像
          base_image: ${{ matrix.docker_image }}
          
          githubToken: ${{ github.token }}
          # 挂载工作目录
          setup: |
            mkdir -p "${PWD}/artifacts"
          dockerRunArgs: |
            --volume "${PWD}/artifacts:/artifacts"
          
          # 在容器内安装环境
          install: |
            apt-get update -q -y
            apt-get install -q -y python3 python3-pip python3-venv git zip
          
          # 在容器内运行构建逻辑
          run: |
            # 1. 创建虚拟环境
            python3 -m venv venv
            source venv/bin/activate
            
            # 2. 安装依赖
            echo "正在安装依赖..."
            pip install --upgrade pip
            pip install onnxruntime pyinstaller torch tqdm numpy onnxscript --no-cache-dir
            
            # 3. 打印环境信息验证
            echo "当前系统架构: $(uname -m)"
            python --version
            
            # 4. 打包可执行文件
            echo "开始打包可执行文件..."
            pyinstaller --onefile --name movie_extractor_${{ matrix.arch }} --clean infer_onnx.py
            
            # 5. 导出 ONNX (按需)
            echo "开始导出 ONNX..."
            python export_onnx.py
            
            # 6. 整理产物到 artifacts 目录
            mkdir -p /artifacts/release/${{ matrix.arch }}
            
            # 复制产物
            if [ -f "dist/movie_extractor_${{ matrix.arch }}" ]; then
              cp dist/movie_extractor_${{ matrix.arch }} /artifacts/release/${{ matrix.arch }}/
              echo "✅二进制文件打包成功"
            else
              echo "❌二进制文件打包失败" && exit 1
            fi
            
            cp movie_extractor.onnx /artifacts/release/${{ matrix.arch }}/ || echo "⚠️ ONNX未生成"
            cp movie_extractor.onnx.data /artifacts/release/${{ matrix.arch }}/ || echo "⚠️ ONNX Data未生成"
            cp vocab.pkl /artifacts/release/${{ matrix.arch }}/ || echo "⚠️ vocab.pkl未生成"
            
            # 7. 生成 ZIP 包
            cd /artifacts/release/${{ matrix.arch }}
            zip -r ../../movie_extractor_${{ matrix.arch }}.zip ./*
            echo "✅ ZIP包生成成功"

      # 上传构建产物
      - name: 上传 ${{ matrix.arch }} ZIP包
        uses: actions/upload-artifact@v4
        with:
          name: movie_extractor_${{ matrix.arch }}_zip
          path: artifacts/movie_extractor_${{ matrix.arch }}.zip

  # ========== 第二阶段：合并产物并提交 ==========
  deploy:
    name: 合并产物并推送到仓库
    runs-on: ubuntu-latest
    needs: build-cross-arch
    steps:
      - name: 拉取仓库代码
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 创建 Release 目录
        run: mkdir -p release
        shell: bash

      - name: 下载 amd64 ZIP
        uses: actions/download-artifact@v4
        with:
          name: movie_extractor_amd64_zip
          path: temp_amd64

      - name: 下载 arm64 ZIP
        uses: actions/download-artifact@v4
        with:
          name: movie_extractor_arm64_zip
          path: temp_arm64

      - name: 移动文件到最终目录
        run: |
          mv temp_amd64/movie_extractor_amd64.zip release/
          mv temp_arm64/movie_extractor_arm64.zip release/
          ls -l release/
        shell: bash

      - name: 推送产物到仓库
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          # 强制添加 release 目录下的 zip 文件
          git add -f release/*.zip
          
          git status
          if git diff --cached --quiet; then
            echo "⚠️ 无新产物需要提交"
          else
            git commit -m "chore: 更新构建产物 amd64/arm64 $(date +%Y%m%d_%H%M%S)"
            git push origin main
            echo "✅ 产物已推送"
          fi